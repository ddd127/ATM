## Описание

В этом репозитории находится консольное java приложение - модель банкомата.

### Запуск приложения:
Для запуска приложения необходимо иметь на компьютере java версии 11 и выше.

* Скачайте репозиторий в виде zip-архива или склонируйте его


Для запуска .jar - файла:

На Linux, из терминала:

> Дайте файлу ATM.jar право на исполнение (chmod +x ATM.jar)
>
> Запустите его (./ATM.jar)


На Windows:

> Запустите файл из cmd командой
>
> `java -jar ATM.jar`

Для сборки и запуска из исходников:

На Linux:
    
> Дайте файлу run.sh право на исполнение(chmod +x run.sh)
>
> Выполните его (./run.sh).


На Windows:
    
> Выполните файл run.bat (например, двойным кликом мыши)

### Взаимодействие с приложением:
Банкомат принимает / выдает купюры следующего номинала:

`{1, 3, 5, 10, 25, 50, 100, 500, 1000, 5000}`

Банкомат поддерживает следующие команды:
* `put X Y` - положить в банкомат `Y` купюр номинала `X`
* `get X` - выдать сумму `X`. В случае, если выдать ровно `X` не удается, банкомат выдает ближайшую меньше либо равную `X` сумму
* `dump` - выводит состояние банкомата как набор строк вида `X Y`, где `X` - номинал купюры, `Y` - число купюр данного номинала
* `state` - выводит суммарное число денег в банкомате
* `quit` - останавливает работу банкомата (и всего приложения). Состояние банкомата не сохраняется

### Алгоритм
Если при операциях `put`, `dump` и `state` алгоритм действий очевиден, то операция `get` требует более детального разбора:

#### Описание алгоритма:

Заведём двумерный массив `dp`:

`dp[запрошенная сумма][количество различных номиналов]`

(Далее для простоты - `values = {1, 3, 5, 10, 25, 50, 100, 500, 1000, 5000}`, следовательно `values[y]` - стоимость купюры с `y`-м по счету номиналом)

В ячейке `dp[x][y]` будем хранить минимальное число купюр номинала ровно `values[y]`, необходимых для того, чтоб набрать сумму `x`, используя первые `y` номиналов, или `-1`, если набрать такую сумму не получается.

Ряд `dp[x][0]` и `dp[0][y]` заполняется очевидно

Далее:

    value = values[y]

    Если dp[x][y - 1] != -1,
        То мы можем набрать сумму x вообще не используя купюры номинала value => dp[x][y] = 0

    Иначе:
        Если мы можем набрать сумму x, используя ненулевое число купюр номинала value, то в dp[x - value][y] лежит неотрицательное число, и набрать нашу сумму используя менее, чем  dp[x - value][y] + 1  купюр номинала value мы не можем (иначе dp[x - value][y] было бы меньше).
        Значит если dp[x - value][y] != -1 и dp[x - value][y] меньше числа имеющихся у нас купюр номианал value, то
            dp[x][y] = dp[x - value][y] + 1
        Иначе мы не можем набрать сумму x используя первые y номиналов:
            dp[x][y] = -1

#### Доказательство корректности:

Для сокращения дальнейшей записи обозначим `n = values.length - 1` - последний валидный индекс в `dp[i]`

Докажем, число `X` может быть составлено из имеющегося у нас набора чисел тогда и только тогда, когда `dp[X][n] != -1`:

##### Обратное следование (если мы нашли `X`, то он точно набирается):

Из хода работы алгоритма очевидно, что для набора каждой достигнутой суммы (той, у которой `dp[sum][n] != -1`), мы потратили валидное число купюр - никогда не брали больше купюр номинала value, чем у нас есть. Значит, если разбиение `X` на купюры найдено, то оно корректно и `X` можно собрать.

Получить это разбиение мы можем, если пройдемся по таблице и восстановим ответ.

##### Прямое следование (если существует разбиение `X`, то мы его найдём):

Если существует разбиение `X`, то оно представимо в виде:

    X = K0 * value[0] + K1 * value[1] + ... + Kn * value[n],
    где для любого i : Ki не больше числа имеющихся у нас купюр номинала values[i]

Тогда рассмотрим, что будет лежать в некоторых ячейках массива `dp`:

Очевидно, что `dp[K0 * value[0]][0] == K0` (из заполнения)

Тогда рассмотрим переход от

`Ki-1` к `Ki`, считая, что

`0 <= dp[K0 * value[0] + K1 * value[1] + ... + Ki-1 * value[i - 1]][i-1] <= Ki-1`:

Пусть `sum = K0 * value[0] + K1 * value[1] + ... + Ki-1 * value[i - 1]`

Поскольку `0 <= dp[sum][i-1] <= Ki-1`, то `dp[sum][i] == 0` (по заполнению)

Из того, что разбиение `X` на сумму произведений валидно, мы знаем, что у нас точно есть хотя бы `Ki` купюр номинала `values[i]`

Из этого и порядка заполения массива следует, что:

Для любого `j : 0 <= j <= Ki: dp[sum + j * value[i]][i] <= j`

А значит, инвариант индукции выполнен :

`0 <= dp[sum + Ki * value[i]][i] <= Ki`

Значит, после заполенения всего массива ячейка `dp[X][n] != -1` и какое-то из разбиаений нашлось

#### Асимптотическая оценка времени работы и доп. памяти:

Каждую ячейку массива `dp[][]` мы заполняем ровно один раз за O(1). Значит, время работы (и доп память) зависят от размеров таблицы.

Размеры таблицы = запрошенная сумма * число различных номиналов. Поскольку из контекста задачи число различных номиналов константно (и равно 10-и), то:

* Время = `O(запрошенная сумма)`
* Доп. память = `O(запрошенная сумма)`

Во избежание лишний действий, можно в случае, если запрошенная сумма больше либо равна имеющейся, отдавать просто все имеющиеся деньги за `O(число различных валют) = O(1)`
